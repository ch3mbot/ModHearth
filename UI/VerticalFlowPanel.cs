using Microsoft.VisualBasic.Devices;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ModHearth.UI
{
    /// <summary>
    /// Basically a FlowLayoutPanel but it makes the scroll bar show up.
    /// The scrollbar dissapearing kepy messing with ModrefPanel width so now we have this.
    /// </summary>
    public class VerticalFlowPanel : FlowLayoutPanel
    {
        // List of DFHMods that this panel should show.
        public List<DFHMod> memberMods;

        // Given a DFHMod, get the corrent child panel.
        public Dictionary<DFHMod, ModRefPanel> modrefMap;

        // Is this panel sorted (is it the right panel).
        public bool sortedPanel;

        // Has this panel been initialized.
        public bool initialized;

        // Constructor settting initialized to fasle, and initializing arrays.
        public VerticalFlowPanel() : base()
        {
            initialized = false;

            // Not necessary since it's done in Initialize but stops warnings from showing up.
            memberMods = new List<DFHMod>();
            modrefMap = new Dictionary<DFHMod, ModRefPanel>();
        }

        // Given an index n, get the nth visible control.
        public Control GetVisibleControlAtIndex(int index)
        {
            return modrefMap[memberMods[index]];
        }

        // Fix the sizes of mod panel children.
        public void FixChildrenStyle()
        {
            SuspendLayout();
            foreach (ModRefPanel modRefPanel in modrefMap.Values)
            {
                modRefPanel.Initialize();
            }
            ResumeLayout();
        }

        // Initialize, should be called once. Adds all the children controls, and does a single fix operation. #TODO: eventually this may be called again if ReInitialize gets used.
        // Things are done here instead of in constructor since constructor is called by the autogenerated MainForm code. Initialize is called when the modlists are done generating.
        public void Initialize(List<ModRefPanel> conts, List<DFHMod> members, bool sortedPanel)
        {
            Console.WriteLine($"Initializing {Name} with {conts.Count} controls, {members.Count} of which are enabled.");

            if (initialized)
            {
                throw new Exception("bro what");
            }

            initialized = true;

            // Set up modrefMap.
            modrefMap = new Dictionary<DFHMod, ModRefPanel>();
            conts.ForEach(x => { modrefMap.Add(x.modref.ToDFHMod(), x); });

            // Suspend layout, and replace all children. Initialize the children as well.
            SuspendLayout();
            Controls.Clear();
            Controls.AddRange(conts.ToArray());
            conts.ForEach(x => { x.Initialize(); });

            // Set if this is sorted.
            this.sortedPanel = sortedPanel;

            // Set visible children, resume the layout, and then fix visible order.
            memberMods = members;
            ResumeLayout(true);
            FixVisibleChildren();
        }

        // If a position is within the bounds of a visible control, output it's index. Otherwise, return false.
        public bool GetIndexAtPosition(Point position, out int index)
        {
            // Localize the position.
            Point pos = PointToClient(position);

            // Generate the list of visible controls.
            List<ModRefPanel> visList = GetVisibleModrefs();

            // If there are no mods in the list, then return 0.
            if (visList.Count == 0)
            {
                index = 0;
                return true;
            }

            // Loop through the list of bisible controls, returning if the point is within bounds.
            // #TODO: instead of bounds use Y level, increasing each time, to account for gaps between modrefpanels due to margins.
            for (index = 0; index < visList.Count; index++)
            {
                if (visList[index].Bounds.Contains(pos) && visList[index].Visible)
                {
                    return true;
                }
            }

            // If the point isn't in any bounds, then check if the point is in form bounds, but below any visible mod. Add 10 to give some wiggle room.
            // This makes it so that if the list is short, dragging to the empty area of the panel adds the mod on the end.
            if (pos.Y < Height + 10 && pos.X > 0 && pos.X < Width && pos.Y > visList[visList.Count - 1].Location.Y + 10)
            {
                index = visList.Count;
                return true;
            }

            // If not found at all, return false.
            return false;
        }

        // Loop through controls and output a list of the visible ones.
        public List<ModRefPanel> GetVisibleModrefs()
        {
            List<ModRefPanel> list = new List<ModRefPanel>();
            foreach (Control control in Controls)
            {
                if (control is ModRefPanel mrp && control.Visible)
                    list.Add(mrp);
            }
            return list;
        }

        // Given a list of problems, highlight the appropriate problem mods, and add mouseover? TODO
        public void ColorProblemMods(List<ModProblem> problems)
        {
            // Generate map of ID to list of problems.
            Dictionary<string, List<ModProblem>> problemIDMap = new Dictionary<string, List<ModProblem>>();
            foreach (ModProblem problem in problems)
            {
                if (!problemIDMap.ContainsKey(problem.problemThrowerID))
                    problemIDMap.Add(problem.problemThrowerID, new List<ModProblem>() { problem });
                else
                    problemIDMap[problem.problemThrowerID].Add(problem);
            }


            // Go through visible modRefPanels and add problems to them
            List<ModRefPanel> visibleRefs = GetVisibleModrefs();
            for (int i = 0; i < visibleRefs.Count; i++)
            {
                if (problemIDMap.ContainsKey(visibleRefs[i].dfmodref.id))
                {
                    visibleRefs[i].SetProblems(problemIDMap[visibleRefs[i].dfmodref.id]);
                }
                else
                {
                    visibleRefs[i].RemoveProblems();
                }
            }
        }

        // Given a new list of what should be visible, updates order and fixes visibility.
        // Other classes handle changing mod lists, this just updates visuals given one.
        public void UpdateVisibleOrder(List<DFHMod> newList)
        {
            // Overwrite member list,
            memberMods = newList;

            // Fix visibility.
            FixVisibleChildren();
        }

        // Fix the visible children with the appropriate function.
        private void FixVisibleChildren()
        {
            // Suspend layout, call the appropriate fix, then resume.
            // #FIXME: verify this if this stops the drawing and undrawing of children that are visible/invisible.
            SuspendLayout();
            if (sortedPanel)
            {
                FixVisibleOrderSorted();
            }
            else
            {
                FixVisibleUnsorted();
            }
            ResumeLayout(true);
        }

        // Fix the order of visible mods. Set the visible ones in order and ignore others.
        private void FixVisibleOrderSorted()
        {
            for (int i = 0; i < Controls.Count; i++)
            {
                // If past member mods, make all invisible.
                if (i >= memberMods.Count)
                {
                    Controls[i].Visible = false;
                }
                else
                {
                    // Find desired panel and set visibility to true. 
                    ModRefPanel desiredPanel = modrefMap[memberMods[i]];
                    desiredPanel.Visible = true;

                    // If the panel at this index isn't the desired panel, put this panel here and decrement I to redo check for this index.
                    if (desiredPanel != Controls[i])
                    {
                        Controls.SetChildIndex(desiredPanel, i);
                        i--;
                    }
                }
            }
        }

        // Unsorted, so order doesn't matter. Simply set the visibility of each control.
        private void FixVisibleUnsorted()
        {
            // Grab all controls and put into hashset.
            HashSet<Control> ToMakeInvis = new HashSet<Control>();
            foreach (Control control in Controls)
            {
                ToMakeInvis.Add(control);
            }

            // Remove the ones that should be visible from ToMakeInvis, and make them visible.
            memberMods.ForEach((x) =>
            {
                ToMakeInvis.Remove(modrefMap[x]);
                modrefMap[x].Visible = true;
            });

            // Commit and make invisible ones invisible.
            foreach (Control control in ToMakeInvis)
            {
                control.Visible = false;
            }
        }

        // Scrollbar generation magic.
        protected override CreateParams CreateParams
        {
            get
            {
                var cp = base.CreateParams;
                cp.Style |= 0x00200000; // WS_VSCROLL
                return cp;
            }
        }

        // Make elements visible/invisible based on filter.
        public void SearchFilter(string filter)
        {
            // Loop through elements and apply filter.
            foreach (ModRefPanel modRefPanel in GetVisibleModrefs())
            {
                // Check for ID or name match.
                modRefPanel.SetFiltered(modRefPanel.modref.name.ToLower().Contains(filter) || modRefPanel.modref.ID.ToLower().Contains(filter));
            }
        }


    }
}

using Microsoft.VisualBasic.Devices;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ModHearth
{
    /// <summary>
    /// Basically a FlowLayoutPanel but it makes the scroll bar show up.
    /// The scrollbar dissapearing kepy messing with ModrefPanel width so now we have this.
    /// </summary>
    public class VerticalFlowPanel : FlowLayoutPanel
    {
        // List of DFHMods that this panel should show.
        public List<DFHMod> memberMods;

        // Given a DFHMod, get the corrent child panel.
        public Dictionary<DFHMod, ModRefPanel> modrefMap;

        // Is this panel sorted (is it the right panel).
        public bool sortedPanel;

        // Has this panel been initialized.
        public bool initialized;

        // Constructor settting initialized to fasle, and initializing arrays.
        public VerticalFlowPanel() : base()
        {
            initialized = false;

            // Not necessary since it's done in Initialize but stops warnings from showing up.
            memberMods = new List<DFHMod>();
            modrefMap = new Dictionary<DFHMod, ModRefPanel>();
        }

        // Given an index n, get the nth visible control.
        public Control GetVisibleControlAtIndex(int index)
        {
            return modrefMap[memberMods[index]];
        }
        
        // #TODO: This may be involved later in refreshing/reloading available mods (finding mod folders again).
        public void ReInitialize(List<ModRefPanel> conts, List<DFHMod> members)
        {
            initialized = false;
            Initialize(conts, members, sortedPanel);
        }

        // Initialize, should be called once. Adds all the children controls, and does a single fix operation. #TODO: eventually this may be called again if ReInitialize gets used.
        // Things are done here instead of in constructor since constructor is called by the autogenerated MainForm code. Initialize is called when the modlists are done generating.
        public void Initialize(List<ModRefPanel> conts, List<DFHMod> members, bool sortedPanel) 
        {
            Console.WriteLine($"Initializing {Name} with {conts.Count} controls, {members.Count} of which are enabled.");

            if (initialized)
            {
                throw new Exception("bro what");
            }

            initialized = true;

            // Set up modrefMap.
            modrefMap = new Dictionary<DFHMod, ModRefPanel>();
            conts.ForEach(x => { modrefMap.Add(x.modref.ToDFHMod(), x); });

            // Suspend layout, and replace all children. Initialize the children as well.
            SuspendLayout();
            Controls.Clear();
            Controls.AddRange(conts.ToArray());
            conts.ForEach(x => { x.Initialize(); });

            // Set if this is sorted.
            this.sortedPanel = sortedPanel;

            // Set visible children, resume the layout, and then fix visible order.
            memberMods = members;
            ResumeLayout(true);
            FixVisibleChildren();
        }

        // If a position is within the bounds of a visible control, output it's index. Otherwise, return false.
        public bool GetIndexAtPosition(Point position, out int index)
        {
            // Localize the position.
            Point pos = PointToClient(position);

            // Generate the list of visible controls.
            List<Control> visList = GetVisibleModrefs();

            // If there are no mods in the list, then return 0.
            if (visList.Count == 0)
            {
                index = 0;
                return true;
            }

            // Loop through the list of bisible controls, returning if the point is within bounds.
            // #TODO: instead of bounds use Y level, increasing each time, to account for gaps between modrefpanels due to margins.
            for (index = 0; index < visList.Count; index++)
            {
                if (visList[index].Bounds.Contains(pos) && visList[index].Visible)
                {
                    return true;
                }
            }

            // If the point isn't in any bounds, then check if the point is in form bounds, but below any visible mod.
            // This makes it so that if the list is short, dragging to the empty area of the panel adds the mod on the end.
            if (pos.Y < Height && pos.X > 0 && pos.X < Width && pos.Y > visList[visList.Count - 1].Location.Y + 10)
            {
                index = visList.Count;
                return true;
            }

            // If not found at all, return false.
            return false;
        }

        // Loop through controls and output a list of the visible ones.
        public List<Control> GetVisibleModrefs()
        {
            List<Control> list = new List<Control>();
            foreach(Control control in Controls) 
            {
                if(control.Visible)
                    list.Add(control);
            }
            return list;
        }

        // Given a new list of what should be visible, updates order and fixes visibility.
        // Other classes handle changing mod lists, this just updates visuals given one.
        public void UpdateVisibleOrder(List<DFHMod> newList)
        {
            // Overwrite member list,
            memberMods = newList;

            // Fix visibility.
            FixVisibleChildren();
        }

        private void FixVisibleChildren()
        {
            // Suspend layout, call the appropriate fix, then resume.
            // #FIXME: verify this if this stops the drawing and undrawing of children that are visible/invisible.
            SuspendLayout();
            if (sortedPanel)
            {
                FixVisibleOrderSorted();
            }
            else
            {
                FixVisibleUnsorted();
            }
            ResumeLayout(true);
        }

        private void FixVisibleOrderSorted()
        {
            for (int i = 0; i < Controls.Count; i++)
            {
                if(i >= memberMods.Count) 
                {
                    Controls[i].Visible = false;
                }
                else if(((ModRefPanel)Controls[i]).dfmodref != memberMods[i]) 
                {
                    Controls.SetChildIndex(modrefMap[memberMods[i]], i);
                    Controls[i].Visible = true;
                    i--;
                }
            }
        }

        // Unsorted, so order doesn't matter. Simply set the visibility of each control.
        private void FixVisibleUnsorted() 
        {
            // Grab all controls and put into hashset.
            HashSet<Control> ToMakeInvis = new HashSet<Control>();
            foreach(Control control in Controls) 
            {
                ToMakeInvis.Add(control);
            }

            // Remove the ones that should be visible from ToMakeInvis, and make them visible.
            memberMods.ForEach((x) => 
            { 
                ToMakeInvis.Remove(modrefMap[x]); 
                modrefMap[x].Visible = true; 
            });

            // Commit and make invisible ones invisible.
            foreach(Control control in ToMakeInvis)
            {
                control.Visible = false;
            }
        }

        // Scrollbar generation magic.
        protected override CreateParams CreateParams
        {
            get
            {
                var cp = base.CreateParams;
                cp.Style |= 0x00200000; // WS_VSCROLL
                return cp;
            }
        }
    }
}
